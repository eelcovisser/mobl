module generation/ui

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MoBL
  lib/editor-common
  desugar
  type
  rename
  util
  generation/emit
  generation/action
  generation/cps-lift
  generation/cps-action

rules

  definition-to-js :
    Template(_, qid, farg*, elems) -> <emit> $[
      [<qid-to-js> qid] = function([fargs]) {
        [init-stats]
        var [root] = $("<span>");
        [body]
      };
      ]
    with {| InTemplate
          : rules ( InTemplate := 1 )
          ; root := <newname> "root"
          ; fargs :=  <filter(farg-to-js); <concat> [<id>, ["namedArgs", "elements", "callback"]]; separate-by(!", "); concat-strings> farg*
          ; body := <elems-to-js-callback(|root)> elems
          ; init-stats := <fargs-to-ref-init-js> farg*
          |}

  definition-to-js :
    Screen(_, qid, farg*, rt, elems) -> <emit> $[
      [<qid-to-js> qid] = function([fargs]) {
        [init-stats]
        var [root] = $("<div>");
        [body]
      };
      ]
    with {| InTemplate
          : rules ( InTemplate := 1 )
          ; root := <newname> "root"
          ; body := <elems-to-js-callback(|root)> elems
          ; fargs :=  <filter(farg-to-js); <concat> [<id>, ["namedArgs", "callback", "screenCallback"]]; separate-by(!", "); concat-strings> farg*
          ; init-stats := <fargs-to-ref-init-js> farg*
          |}

  elems-to-js-callback(|root) =
    <concat; elems-to-js(|root)> [<id>, [$[callback([root]); return;]]]

  elems-to-js(|root) :
    [Template(_, qid, farg*, elems)|rest*] -> $[
      var [<qid-to-js> qid] = function([fargs]) {
        [init-stats]
        var [root2] = $("<span>");
        [body]
      };
      [<elems-to-js(|root)> rest*]
      ]
    with root2 := <newname> "root"
       ; fargs :=  <filter(farg-to-js); <concat> [<id>, ["namedArgs", "elements", "callback"]]; separate-by(!", "); concat-strings> farg*
       ; body := <elems-to-js-callback(|root2)> elems
       ; init-stats := <fargs-to-ref-init-js> farg*

  elems-to-js(|root) :
    [TemplateCall(e, arg*, elems)|rest*] ->
    $[var [nodes] = $("<span>");
      [root].append([nodes]);
      [templatecall]
]
    with elem-root := <newname> "root"
       ; nodes := <newname> "nodes"
       ; elems-fun := $[function(namedArgs, elements, callback) {
                          var [elem-root] = $("<span>");
                          [<elems-to-js-callback(|elem-root)> elems]
                        }]
       ; if not(Var(QId(_, _)) := e) then
           watch-e-expr* := <collect(?Var(_) <+ ?FieldAccess(_, _))> e
         else
           watch-e-expr* := []
         end
       ; watch-expr* := <map(find-watchable-expressions); concat> arg*
       ; args  := <ref-arguments-to-js; <concat> [<id>, [elems-fun,
           $[function(node) {
               var oldNodes = [nodes];
               [nodes] = node.contents();
               oldNodes.replaceWith([nodes]);
               [<elems-to-js(|root)> rest*]
             }]
         ]]; separate-by(!", "); concat-strings> arg*
       ; templatecall := <concat-strings> ["(", <expression-to-js> e, ")(", args, ");"]

  elems-to-js(|root) :
    [TemplateCall(e, arg*, elems)|rest*] ->
    $[var [nodes] = $("<span>");
      [root].append([nodes]);
      [templatecall]
]
    with elem-root := <newname> "root"
       ; nodes := <newname> "nodes"
       ; elems-fun := $[function(namedArgs, elements, callback) {
                          var [elem-root] = $("<span>");
                          [<elems-to-js-callback(|elem-root)> elems]
                        }]
       ; if not(Var(QId(_, _)) := e) then
           watch-e-expr* := <collect(?Var(_) <+ ?FieldAccess(_, _))> e
         else
           watch-e-expr* := []
         end
       ; watch-expr* := <map(find-watchable-expressions); concat> arg*
       ; args  := <ref-arguments-to-js; <concat> [<id>, [elems-fun,
           $[function(node) {
               var oldNodes = [nodes];
               [nodes] = node.contents();
               oldNodes.replaceWith([nodes]);
               [<elems-to-js(|root)> rest*]
             }]
         ]]; separate-by(!", "); concat-strings> arg*
       ; templatecall := <concat-strings> ["(", <expression-to-js> e, ")(", args, ");"]


   find-watchable-expressions =
        not(?Var(_))
        ; not(?FieldAccess(_, _))
        ; not(?Indexer(_, _))
        ; collect(?Var(_) <+ ?FieldAccess(_, _))
     <+ ![]

  exp-to-watcher-js(|renderTemplate) :
    e -> $[[<ref-expression-to-js> e].addEventListener('change', function() {
             [renderTemplate](true);
           });
]

  elems-to-js(|root) :
    [tg@Html(tag, arg*, elems, _)|rest*] -> $[
      var [node] = $("<[tag] [<escape> args]>");
      [<filter(databind-tag-arg-to-js(|tg, node)); concat-strings> arg*]
      [body]
    ]
    with args := <filter(tag-arg-to-html); separate-by(!" "); concat-strings> arg*
       ; node := <newname> "node"
       ; body := <elems-to-js(|node)> <concat> [elems, [
           $[[root].append([node]);
           [<elems-to-js(|root)> rest*]]]]


  elems-to-js(|root) :
    [f@Function(_, _, _, _, _)|rest*] -> $[
      [<function-to-js> f]
      [<elems-to-js(|root)> rest*]]

  elems-to-js(|root) :
    [f@SyncFunction(_, _, _, _, _)|rest*] -> $[
      [<function-to-js> f]
      [<elems-to-js(|root)> rest*]]

  elems-to-js(|root) :
    [s|rest*] -> $[[s][<elems-to-js(|root)> rest*]]
    where <is-string> s

  elems-to-js(|root) :
    [Init(init-stats)|rest*] -> <concat; cps-statements> [<cps-lift-expressions> init-stats, [<elems-to-js(|root)> rest*]]

  elems-to-js(|root) :
    [] -> ""

  tag-arg-to-html :
    HtmlArg(name, String(s)) -> $[[name]=[s]]

  databind-tag-arg-to-js(|tg, node) :
    HtmlArg(name, e) -> $[
      var [r] = [es];
      if([r].get() !== null) {
        [node].attr('[name]', [r].get());
        [r].addEventListener('change', function(_, ref, val) {
          if(ref === [r]) {
            [node].attr('[name]', val);
          } else {
            console.log("Garbage!");
          }
        });
        [subscriptions]
      }
      [r].rebind();
    ]
    where not(String(_) := e)
        ; not(SimpleType(QId("mobl", "Callback")) := <type-of> e)
    with es := <ref-expression-to-js> e
       ; r  := <newname> "ref"
       ; watch-expr* := <find-watchable-expressions> e
       ; subscriptions := <map(exp-to-html-watcher-js(|node, name, <expression-to-js> e)); concat-strings> watch-expr*

  exp-to-html-watcher-js(|node, attr, es) :
    e -> $[[<ref-expression-to-js> e].addEventListener('change', function() {
             [node].attr('[attr]', [es]);
           });
]


  databind-tag-arg-to-js(|tg, node) :
    HtmlArg(name, e) -> $[
      var [val] = [es];
      if([val] !== null) {
        [node].bind('[<string-replace(|"on", "")> name]', [val]);
      }
    ]
    where SimpleType(QId("mobl", "Callback")) := <type-of> e
        ; not("onclick" := name)
    with es := <expression-to-js> e
       ; val  := <newname> "val"

  databind-tag-arg-to-js(|tg, node) :
    HtmlArg("onclick", e) -> $[
      var [val] = [es];
      if([val] !== null) {
        [node].tap([val]);
      }
    ]
    where SimpleType(QId("mobl", "Callback")) := <type-of> e
    with es := <expression-to-js> e
       ; val  := <newname> "val"


  databind-tag-arg-to-js(|tg, node) :
    HtmlDatabindArg(e) -> $[
      var [r] = [es];
      [node].[method]([r].get());
      [r].addEventListener('change', function(_, ref, val) {
        if(ref === [r]) {
          [node].[method]([typeconverter](val));
        } else {
          console.log("Garbage!");
        }
      });
      [r].rebind();
      [subs]
    ]
    where Html(tag, arg*, _, _) := tg
        ; [] := <filter(?HtmlArg("type", String("\"checkbox\"")))> arg*
    with es := <ref-expression-to-js> e
       ; r  := <newname> "ref"
       ; typeconverter := <concat-strings> ["mobl.stringTo", <type-of; ?SimpleType(<id>); qid-to-html> e]
       ; if "input" := tag <+ "textarea" := tag then
           method := "val"
           ; subs := $[
               [node].change(function() {
                 [es].set([typeconverter]([node].[method]()));
               });
             ]
         else
           method := "text"
           ; subs := ""
         end

  databind-tag-arg-to-js(|tg, node) :
    HtmlDatabindArg(e) -> $[
      var [r] = [es];
      [node].attr('checked', !![r].get());
      [r].addSetListener(function(ref, val) {
        if(ref === [r]) [node].attr('checked', !!val);
      });
      [node].change(function() {
        [es].set(!![node].attr('checked'));
      });
    ]
    where Html("input", arg*, _, _) := tg
        ; not([] := <filter(?HtmlArg("type", String("\"checkbox\"")))> arg*)
    with es := <ref-expression-to-js> e
       ; r  := <newname> "ref"

  elems-to-js(|root) :
    [List(lvalue, t, e, elems)|rest*] -> $[
      var [node] = $("<span>");
      [root].append([node]);
      var [rest] = function() {
        [<elems-to-js(|root)> rest*]
      };
      var [list];
      var [renderList] = function(isRerender) {
        [list] = [<expression-to-js> e];
        [list].list(null, function(results) {
          [node].empty();
          results = results.reverse();
          function renderOne() {
              [vardecls]
              [assigns]
              [<concat; elems-to-js(|node)> [elems, [$[
                if(results.length > 0) {
                  renderOne();
                } else if(!isRerender) {
                  mobl.delayedUpdateScrollers();
                  [rest]();
                } else {
                  mobl.delayedUpdateScrollers();
                }
              ]]]]
          }
          if(results.length > 0) {
            renderOne();
          } else if(!isRerender) {
            mobl.delayedUpdateScrollers();
            [rest]();
          } else {
            mobl.delayedUpdateScrollers();
          }
        });
      };
      [renderList](false);
      [list].addEventListener('change', function() { [renderList](true); });
      [subscriptions]
    ]
    with node := <newname> "node"
       ; rest := <newname> "rest"
       ; i := <newname> "i"
       ; renderList := <newname> "renderList"
       ; list := <newname> "list"
       ; oldScope := <newname> "oldScope"
       ; vardecls := <map(!$[var [<id>]; ]); concat-strings> <lvalue-vars> lvalue
       ; assigns := <desugar-all; (map(statement-to-js); concat-strings <+ statement-to-js)> Assignment(lvalue, MethodCall(Var("results"), "pop", []))
       ; subscriptions := <collect-all(?MethodCall(_, _, <id>) <+ ?Call(_, _)); find-watchable-expressions; map(exp-to-watcher-js(|renderList)); concat-strings> e

  elems-to-js(|root) :
    [ConditionalDisplay(e, elems)|rest*] -> $[
      var [node] = $("<span>");
      [root].append([node]);
      var [renderCond] = function(isRerender) {
        var [value] = [<expression-to-js> e];
        [node].empty();
        if([value]) {
          [<elems-to-js(|node)> elems]
        }
        if(!isRerender) {
          [<elems-to-js(|root)> rest*]
        }
      };
      [renderCond](false);
      [subscriptions]
    ]
    with node := <newname> "node"
       ; value := <newname> "value"
       ; renderCond := <newname> "renderCond"
       ; subscriptions := <collect(?Var(_) <+ ?FieldAccess(_, _)); map(exp-to-watcher-js(|renderCond)); concat-strings> e

  elems-to-js(|root) :
    [ScreenString(s)|rest*] -> $[
      [root].append([s]);
      [<elems-to-js(|root)> rest*]]

  elems-to-js(|root) :
    [vd@VarDecl(x, t, e)|rest] -> <concat; elems-to-js(|root)> [<cps-lift-expressions> [vd], rest]
    where not(<is-sync> e)

  elems-to-js(|root) :
    [vd@VarDecl(x, t, e)|rest] -> $[
      var [x] = ref([<expression-to-js> e]);
      [subscriptions]
      [<elems-to-js(|root)> rest]]
    where <is-sync> e
        ; subscriptions := <find-watchable-expressions; map(exp-to-update-ref-js(|x, e)); concat-strings> e

  exp-to-update-ref-js(|x, exp) :
    e -> $[[es].addEventListener('change', function() {
             [x].set([<expression-to-js> exp]);
           });
]
  where es := <ref-expression-to-js> e

  elems-to-js(|root) :
    [vd@VarDeclInferred(x, e)|rest] -> <concat; elems-to-js(|root)> [<cps-lift-expressions> [vd], rest]
    where not(<is-sync> e)

  elems-to-js(|root) :
    [vd@VarDeclInferred(x, e)|rest] -> $[
      var [x] = ref([<expression-to-js> e]);
      [subscriptions]
      [<elems-to-js(|root)> rest]]
    where <is-sync> e
        ; subscriptions := <find-watchable-expressions; map(exp-to-update-ref-js(|x, e)); concat-strings> e

rules // utils

  qid-to-html :
    s -> s
    where is-string

  qid-to-html :
    QId(qid, x) -> $[[qids]__[x]]
    with qids := <qid-to-html> qid